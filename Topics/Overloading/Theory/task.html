<h2>Overloading</h2>
<div class="step-text">
<p><strong>Method overloading</strong> is a programming concept that allows you to design numerous methods that share the same name but have distinct arguments. When a method is called, the language determines which version of the method to run based on the number, types, and order of the arguments given. With method overloading, you can declare different versions of a method with the same name, creating code that is more concise and easier to understand while still handling all sorts of inputs.</p><p>Overloading allows you to change a methodâ€™s signature: the number of parameters, their type, or both. If methods have the same name, but a different number or type of parameters, they are <strong>overloaded</strong>. It means you can <a class="theory-lookup" href="/learn/step/7762" rel="noopener noreferrer nofollow" target="_blank" title="In Java, invoke means to execute a specific set of code within a method. | It involves using the method's name and providing the necessary arguments, if any. When a method is invoked, the program's control is transferred to the method's code, allowing it to perform its intended operation. Invoking a method promotes code reusability and modularity, making the code more organized, maintainable, and easier to understand.">invoke</a> different methods by the same name by passing different arguments.</p><h5 id="what-is-a-method-signature">What is a method signature?</h5><p>A <a class="theory-lookup" href="/learn/step/10982" rel="noopener noreferrer nofollow" target="_blank" title="A method signature in Java refers to the unique identifier of a method, which includes the method's name and its parameter types. | This signature is used to differentiate between methods with the same name but different parameter types or number of parameters, enabling method overloading. The method signature does not consider the return type, but it is crucial in determining the method that will be invoked during runtime based on the arguments passed to it. Therefore, a method signature is a fundamental concept in Java that allows for polymorphism and code reusability.">method signature</a> is a unique identifier for a method that comprises the method's name and its <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, argument type refers to the data type of the value that is passed to a method when it is invoked. | This can be a primitive type like int, double, or boolean, or a reference type like String, Array, or a user-defined class. The argument type is defined in the method signature, which is the part of the method declaration in parentheses after the method name. This signature reflects how the arguments will be passed to the method. If a method does not take any arguments, it is known as a non-parameterized method.">argument types</a>. It specifies the number, type, and order of <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a parameter is a variable that is used within a method to receive a value that is passed to the method when it is invoked. | The parameter definition includes the type, number, and order of the parameters, which reflects how they will be passed to the method. A method may have a parameterized argument and return type, and the class provides methods to examine the return type or argument of the method. The parameter of a method is a value that is used inside the method, and it is declared in the parentheses following the method name.">parameters</a> that a method expects as arguments to determine its input.</p><pre><code class="language-java">public int sum(int a, int b)
</code></pre><p>Here, the method name is "<a class="theory-lookup" href="/learn/step/3565" rel="noopener noreferrer nofollow" target="_blank" title="In Java, 'sum' is not a predefined keyword or term. | However, in programming, 'sum' is often used to refer to the total or combined value of multiple numbers or variables. For instance, if you have two integer variables 'a' and 'b', you might calculate their sum with the expression 'a + b'. This would give you the combined value of 'a' and 'b'. In Java, you could then store this sum in a new variable, say 'c', with the statement 'c = a + b'.">sum</a>", and it takes two integer parameters named "a" and "b". This signature indicates that the "sum" function accepts two integer inputs. Method signatures are used to distinguish between methods with the same name that take various kinds or quantities of parameters and may be overloaded as a <a class="theory-lookup" href="/learn/step/9955" rel="noopener noreferrer nofollow" target="_blank" title="In Java, the term result typically refers to the output or value produced by a method or function after it has completed its execution. | This result can be of any data type, including primitive types like int, float, or boolean, or reference types like arrays or objects. The result is usually returned to the caller of the method or function using the return statement. It's important to note that not all methods or functions in Java have a result, as some are designed to perform a specific action or modify an object's state without producing a value.">result</a>. When a method is called, the compiler compares its signature to the method signature of the method specification so as to identify which method was called.</p><h5 id="how-to-overload-methods">How to overload methods</h5><p>As an example, let's consider some overloaded methods from the standard class <code class="language-java">Math</code>:</p><pre><code class="language-java">public static int abs(int a) { return (a &lt; 0) ? -a : a; }

public static float abs(float a) { return (a &lt;= 0.0F) ? 0.0F - a : a; }</code></pre><p>Since one of these methods has an integer parameter and another has a float parameter, but they have the same name, they are using method overloading.</p><p>It is impossible to declare more than one method with the same signature (method name and number, types and order of parameters). The code snippet below leads to a compilation error <code class="language-java">abs(int) is already defined</code>. Despite the fact that the methods have different <a class="theory-lookup" href="/learn/step/3539" rel="noopener noreferrer nofollow" target="_blank" title="In Java, return type is the data type of the value that a method returns after its execution. | This value can be of a primitive type like int, float, or boolean, or a reference type like String or an object of a class. If a method does not return any value, it is known as a void method. The return type is specified after the method name, enclosed in parentheses, and it determines the type of value that can be assigned to the method when it is called.">return types</a>, their signatures are identical:</p><pre><code class="language-java">public static int abs(int a) { return (a &lt; 0) ? -a : a; } // abs(int) is already defined

public static float abs(int a) { return (a &lt; 0.0F) ? 0.0F - a : a; } // abs(int) is already defined</code></pre><p>Here are four methods <code class="language-java">print</code> for printing different values.</p><pre><code class="language-java">public static void print(String stringToPrint) {
    System.out.println(stringToPrint);
}

public static void print(String stringToPrint, int times) {
    for (int i = 0; i &lt; times; i++) {
        System.out.println(stringToPrint);
    }
}

public static void print(int times, String stringToPrint) {
    for (int i = 0; i &lt; times; i++) {
        System.out.println(stringToPrint);
    }
}

public static void print(int val) {
    System.out.println(val);
}</code></pre><p>The first method <a class="theory-lookup" href="/learn/step/13775" rel="noopener noreferrer nofollow" target="_blank" title="In Java, 'print' is a statement used to display output to the console. | It writes the specified text or variable value to the standard output stream, which is typically the console. Unlike 'println', 'print' does not add a newline character after the output, meaning that subsequent print statements will continue writing on the same line. It's a fundamental tool for providing feedback and displaying results in a Java program.">prints</a> an input string, the second and the third ones print an input string a given number of times, and the last one prints an integer value. These methods are overloaded.</p><p>Let's invoke these methods:</p><pre><code class="language-java">print("some string");
print("another string", 2);
print(2, "another string again");
print(5);</code></pre><p>As you can see, it's possible to <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, call is a term used to describe the process of invoking or executing a method, constructor, or function. | This action can be initiated from within another method, constructor, or function, and it allows for the sharing and reuse of code. The call can be made using different access modifiers, such as public, private, or protected, which determine where the call can be made from. Additionally, calls can be made using various types of parameters, including primitive types, objects, and arrays, which are passed to the method, constructor, or function being called.">call</a> any of these methods by the same name passing suitable arguments. The code outputs:</p><pre><code class="language-no-highlight">some string
another string
another string
another string again
another string again
5</code></pre><p>Note that in the case where methods have the same types of parameters, changing the order of these parameters is a valid case of overloading, as you can see in the second and third methods from the example above.</p><p>The overloading mechanism allows us not to write different names for methods that perform similar operations.</p><h5 id="overloading-and-casting">Overloading and casting</h5><p>To understand how overloading deals with<strong> <a class="theory-lookup" href="/learn/step/3510" rel="noopener noreferrer nofollow" target="_blank" title="In Java, type casting is the process of converting a value of one data type to another. | There are two types of casting: implicit and explicit. Implicit casting, also known as widening, occurs automatically when the target type is larger than the source type. Explicit casting, also known as narrowing, is done manually by the programmer and can result in type overflow if the target type cannot store the full value of the source type. It is important to note that casting between primitive types and the Object type is not possible in Java.">type casting</a></strong>, let's consider an example of overloaded methods that only differ in the type of the single argument and see when each of them will be invoked and why.</p><pre><code class="language-java">public class OverloadingExample {

    public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void print(int a) {
        System.out.println("int arg: " + a);
    }

    public static void print(long a) {
        System.out.println("long arg: " + a);
    }

    public static void print(double a) {
        System.out.println("double arg: " + a);
    }

    public static void main(String[] args) {
        print(100);
    }
}</code></pre><p>Now, if we call <code class="language-java">print(100)</code>, the program outputs:</p><pre><code class="language-no-highlight">int arg: 100</code></pre><p>What we see here is that 100 is treated as <code class="language-java">int</code>, and the corresponding method is invoked.</p><p>In the case where the method parameter type is not exactly the same as the type of the passed argument, the compiler chooses the method that has the closest argument type in order of <a class="theory-lookup" href="/learn/step/3510" rel="noopener noreferrer nofollow" target="_blank" title="Implicit casting, also known as automatic casting, is a process in Java where the compiler automatically converts a value of one type to another type, without requiring any explicit instructions from the programmer. | This occurs when the target type is wider than the source type, meaning that the target type can accommodate all possible values of the source type. Examples of implicit casting include converting a smaller integer type to a larger integer type, or a floating-point type to a larger floating-point type.">implicit casting</a>.</p><p>Since all integer literals are treated as <code class="language-java">int</code> by default, <code class="language-java">int</code> will be the starting point. The closest one will then be <code class="language-java">long</code>.</p><p>Let's remove or comment out the method <code class="language-java">public static void print(int a)</code>, then recompile and run the program again. The result is as expected:</p><pre><code class="language-no-highlight">long arg: 100</code></pre><p>Ok, now let's remove <code class="language-java">public static void print(long a)</code> too. Since we have no method with the <code class="language-java">float</code>  argument, the next type in order of the implicit type casting will be <code class="language-java">double</code>. After recompiling, the program outputs:</p><pre><code class="language-no-highlight">double arg: 100.0</code></pre><p>If we remove the method <code class="language-java">public static void print(double a)</code> the only method we have left is the one with <code class="language-java">short</code> type of argument. The program won't <a class="theory-lookup" href="/learn/step/3536" rel="noopener noreferrer nofollow" target="_blank" title="In Java, compile is the process of translating source code into bytecode, which is a platform-independent code that can be executed on any device with a Java Virtual Machine (JVM). | This process is performed by the Java compiler, which checks the source code for syntax errors and generates a .class file containing the bytecode. The JVM then loads and executes this bytecode, enabling the write once, run anywhere philosophy of Java. Compilation ensures type safety and enables early error detection, making the code more reliable and maintainable.">compile</a> if we just call <code class="language-java">print(100)</code> as we did before. </p><p>Here is why: when we pass some value to the method, the compiler does not evaluate it. All that is known is that it is an <a class="theory-lookup" href="/learn/step/10545" rel="noopener noreferrer nofollow" target="_blank" title="An integer literal in Java is a type of numeric literal that represents integer numbers. | It can be represented in decimal, hexadecimal, octal, or binary format. By default, an integer literal is of the int type, but if the value is greater than the range of an int, it can be represented as a long integer literal by adding an 'L' or 'l' at the end.">integer literal</a>, so it has the <a class="theory-lookup" href="/learn/step/3565" rel="noopener noreferrer nofollow" target="_blank" title="In Java, the integer type is a primitive data type that represents whole numbers, including positive, negative, and zero. | The most commonly used integer types are `int` and `long`. The `int` type can store numbers within a smaller range, which is often enough for many purposes. The `long` type can store larger numbers. Integer types can be used to perform all arithmetic operations, such as addition, subtraction, multiplication, division, and modulus.">integer type</a>. </p><p>In our case, 100 is treated as an <code class="language-java">int</code> by <a class="theory-lookup" href="/learn/step/3535" rel="noopener noreferrer nofollow" target="_blank" title="In Java, the default value for a variable is the default value of its type. | If you don't define a specific constructor, the default constructor will not be created. If a class has no explicit constructor, the Java compiler automatically provides a default no-argument constructor.">default</a> and JVM doesn't know if the passed value can be cast to <code class="language-java">short</code> safely. So, the only way to pass the <code class="language-java">short</code> argument is by casting the value explicitly:</p><pre><code class="language-java"> public class OverloadingExample {

    public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void main(String[] args) {
        print((short) 100);  // explicit casting 
    }
}</code></pre><h5 id="conclusion">Conclusion </h5><p>Method overloading is an essential concept in <a class="theory-lookup" href="/learn/step/4727" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an object is an instance of a class. | It represents a real-world entity with a specific state and behavior. The state of an object is defined by the values assigned to its fields or attributes, while its behavior is defined by the methods it can execute. Objects are created on the heap and are accessed through references, which are variables that store the memory address of the object.">object</a>-oriented programming that makes the code more concise, easier to read and maintain, and enables its reuse. By understanding the method signature and the behavior of the compiler when matching method calls to method definitions, developers can take advantage of the flexibility of method overloading and create more versatile and reusable code.</p>
</div>
